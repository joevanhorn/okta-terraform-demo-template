#!/usr/bin/env python3
"""
Export Okta groups to Terraform configuration.

This script fetches groups from an Okta org and generates Terraform
configuration files for creating those groups in another org.

Usage:
    # Export groups to Terraform
    python scripts/export_groups_to_terraform.py \
        --output environments/myorg/terraform/groups_imported.tf

    # Exclude system groups
    python scripts/export_groups_to_terraform.py \
        --output groups.tf --exclude-system

    # Filter by name pattern
    python scripts/export_groups_to_terraform.py \
        --output groups.tf --name-pattern "Group -"

Environment Variables:
    OKTA_ORG_NAME   - Okta org name (source)
    OKTA_BASE_URL   - Okta base URL (default: oktapreview.com)
    OKTA_API_TOKEN  - Okta API token
"""

import argparse
import json
import os
import re
import sys
import time
from typing import Dict, List, Optional

import requests


# System groups to exclude by default
SYSTEM_GROUP_NAMES = [
    "Everyone",
    "Administrators",
]


class OktaClient:
    """Client for Okta API operations."""

    def __init__(self, org_name: str, base_url: str, api_token: str):
        self.org_name = org_name
        self.base_url = f"https://{org_name}.{base_url}"
        self.api_url = f"{self.base_url}/api/v1"
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"SSWS {api_token}",
            "Accept": "application/json",
            "Content-Type": "application/json",
        })

    def _handle_rate_limit(self, response: requests.Response) -> None:
        if response.status_code == 429:
            reset_time = int(response.headers.get('X-Rate-Limit-Reset', time.time() + 60))
            wait_time = max(reset_time - time.time() + 1, 1)
            print(f"  Rate limited. Waiting {wait_time:.0f}s...")
            time.sleep(wait_time)

    def _make_request(self, method: str, url: str, **kwargs) -> requests.Response:
        max_retries = 3
        for attempt in range(max_retries):
            response = self.session.request(method, url, **kwargs)
            if response.status_code == 429:
                self._handle_rate_limit(response)
                continue
            return response
        return response

    def get_groups(self, group_type: str = "OKTA_GROUP") -> List[Dict]:
        """Get all groups of specified type."""
        print(f"Fetching {group_type} groups...")
        url = f"{self.api_url}/groups"
        params = {"limit": 200, "filter": f'type eq "{group_type}"'}

        groups = []
        while url:
            response = self._make_request("GET", url, params=params)
            if not response.ok:
                print(f"  Error: {response.status_code} - {response.text}")
                break
            groups.extend(response.json())
            url = None
            params = {}
            if "next" in response.links:
                url = response.links["next"]["url"]

        print(f"  Found {len(groups)} groups")
        return groups


def sanitize_resource_name(name: str) -> str:
    """Convert group name to valid Terraform resource name."""
    # Replace spaces and special chars with underscores
    sanitized = re.sub(r'[^a-zA-Z0-9]', '_', name.lower())
    # Remove consecutive underscores
    sanitized = re.sub(r'_+', '_', sanitized)
    # Remove leading/trailing underscores
    sanitized = sanitized.strip('_')
    # Ensure it starts with a letter
    if sanitized and sanitized[0].isdigit():
        sanitized = 'group_' + sanitized
    return sanitized or 'unnamed_group'


def escape_terraform_string(s: str) -> str:
    """Escape special characters for Terraform string."""
    if s is None:
        return ""
    # Escape backslashes first, then quotes
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    # Escape dollar signs for Terraform interpolation
    s = s.replace('$', '$$')
    return s


def generate_terraform(groups: List[Dict], existing_names: set) -> str:
    """Generate Terraform configuration for groups."""
    lines = []
    lines.append("# =============================================================================")
    lines.append("# IMPORTED GROUPS FROM SOURCE ORG")
    lines.append("# =============================================================================")
    lines.append("# These groups were imported from the source Okta org.")
    lines.append("# They can be used for policy-based entitlement assignments.")
    lines.append("#")
    lines.append("# Generated by: scripts/export_groups_to_terraform.py")
    lines.append("# =============================================================================")
    lines.append("")

    used_names = set()
    skipped = 0

    for group in sorted(groups, key=lambda g: g.get('profile', {}).get('name', '')):
        profile = group.get('profile', {})
        name = profile.get('name', '')
        description = profile.get('description', '')

        if not name:
            continue

        # Skip if already exists in target
        if name in existing_names:
            print(f"  Skipping (already exists): {name}")
            skipped += 1
            continue

        # Generate unique resource name
        resource_name = sanitize_resource_name(name)
        base_name = resource_name
        counter = 1
        while resource_name in used_names:
            resource_name = f"{base_name}_{counter}"
            counter += 1
        used_names.add(resource_name)

        lines.append(f'resource "okta_group" "{resource_name}" {{')
        lines.append(f'  name        = "{escape_terraform_string(name)}"')

        if description:
            lines.append(f'  description = "{escape_terraform_string(description)}"')

        # Handle custom profile attributes
        custom_attrs = {}
        for key, value in profile.items():
            if key not in ('name', 'description'):
                custom_attrs[key] = value

        if custom_attrs:
            # Format JSON nicely
            json_str = json.dumps(custom_attrs, indent=4)
            # Escape for Terraform
            json_str = json_str.replace('${', '$${')
            lines.append('')
            lines.append('  custom_profile_attributes = jsonencode({')
            for key, value in custom_attrs.items():
                if isinstance(value, list):
                    # Format list on one line if short, multiple lines if long
                    list_str = json.dumps(value)
                    lines.append(f'    {key} = {list_str}')
                elif isinstance(value, str):
                    lines.append(f'    {key} = "{escape_terraform_string(value)}"')
                else:
                    lines.append(f'    {key} = {json.dumps(value)}')
            lines.append('  })')

        lines.append('}')
        lines.append('')

    if skipped > 0:
        print(f"  Skipped {skipped} groups (already exist in target)")

    return '\n'.join(lines)


def get_existing_group_names(tf_dir: str) -> set:
    """Parse existing Terraform files to find group names."""
    existing = set()

    if not os.path.isdir(tf_dir):
        return existing

    for filename in os.listdir(tf_dir):
        if not filename.endswith('.tf'):
            continue

        filepath = os.path.join(tf_dir, filename)
        try:
            with open(filepath, 'r') as f:
                content = f.read()

            # Find all group names in okta_group resources
            # Match: name = "Group Name"
            matches = re.findall(r'resource\s+"okta_group".*?name\s*=\s*"([^"]+)"', content, re.DOTALL)
            existing.update(matches)
        except Exception as e:
            print(f"  Warning: Could not parse {filename}: {e}")

    return existing


def main():
    parser = argparse.ArgumentParser(
        description="Export Okta groups to Terraform configuration"
    )
    parser.add_argument("--output", "-o", required=True,
                        help="Output Terraform file path")
    parser.add_argument("--exclude-system", action="store_true",
                        help="Exclude system groups (Everyone, Administrators)")
    parser.add_argument("--name-pattern", type=str,
                        help="Only include groups matching this pattern (regex)")
    parser.add_argument("--skip-existing", action="store_true", default=True,
                        help="Skip groups that already exist in target Terraform files")
    parser.add_argument("--verbose", "-v", action="store_true",
                        help="Verbose output")

    args = parser.parse_args()

    # Get Okta credentials
    org_name = os.environ.get("OKTA_ORG_NAME")
    base_url = os.environ.get("OKTA_BASE_URL", "oktapreview.com")
    api_token = os.environ.get("OKTA_API_TOKEN")

    if not org_name or not api_token:
        print("Error: OKTA_ORG_NAME and OKTA_API_TOKEN environment variables required")
        sys.exit(1)

    print(f"\nExporting groups from: {org_name}.{base_url}")

    # Connect to Okta
    client = OktaClient(org_name, base_url, api_token)

    # Get groups
    groups = client.get_groups("OKTA_GROUP")

    # Filter groups
    original_count = len(groups)

    if args.exclude_system:
        groups = [g for g in groups
                  if g.get('profile', {}).get('name') not in SYSTEM_GROUP_NAMES]
        print(f"  Excluded {original_count - len(groups)} system groups")

    if args.name_pattern:
        pattern = re.compile(args.name_pattern, re.IGNORECASE)
        before = len(groups)
        groups = [g for g in groups
                  if pattern.search(g.get('profile', {}).get('name', ''))]
        print(f"  Filtered to {len(groups)} groups matching pattern '{args.name_pattern}'")

    if not groups:
        print("No groups to export.")
        sys.exit(0)

    # Get existing group names from target Terraform directory
    existing_names = set()
    if args.skip_existing:
        tf_dir = os.path.dirname(args.output)
        if tf_dir:
            existing_names = get_existing_group_names(tf_dir)
            if existing_names:
                print(f"  Found {len(existing_names)} existing groups in Terraform files")

    # Generate Terraform
    print(f"\nGenerating Terraform for {len(groups)} groups...")
    terraform_config = generate_terraform(groups, existing_names)

    # Write output
    os.makedirs(os.path.dirname(args.output) or '.', exist_ok=True)
    with open(args.output, 'w') as f:
        f.write(terraform_config)

    print(f"\nWrote Terraform configuration to: {args.output}")

    # Count generated resources
    resource_count = terraform_config.count('resource "okta_group"')
    print(f"Generated {resource_count} group resources")

    if resource_count > 0:
        print("\nNext steps:")
        print(f"  1. Review the generated file: {args.output}")
        print("  2. Run: terraform plan")
        print("  3. Run: terraform apply")

    return 0


if __name__ == "__main__":
    sys.exit(main())
