#!/usr/bin/env python3
"""
Okta Demo Builder - Generate Terraform files from YAML configuration.

Usage:
    python scripts/build_demo.py --config demo-builder/demo-config.yaml
    python scripts/build_demo.py --config demo-config.yaml --dry-run
    python scripts/build_demo.py --config demo-config.yaml --validate
    python scripts/build_demo.py --interactive

For help:
    python scripts/build_demo.py --help
"""

import argparse
import json
import os
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any

try:
    import yaml
except ImportError:
    print("Error: PyYAML is required. Install with: pip install pyyaml")
    sys.exit(1)

try:
    import jsonschema
except ImportError:
    jsonschema = None  # Optional - validation will be skipped


# =============================================================================
# CONSTANTS
# =============================================================================

SCRIPT_DIR = Path(__file__).parent
REPO_ROOT = SCRIPT_DIR.parent
DEMO_BUILDER_DIR = REPO_ROOT / "demo-builder"
SCHEMA_FILE = DEMO_BUILDER_DIR / "demo-config.schema.json"

# Template for Terraform files
TF_HEADER = '''# =============================================================================
# {title}
# =============================================================================
# Generated by: python scripts/build_demo.py
# Config file: {config_file}
# Generated at: {timestamp}
#
# DO NOT EDIT MANUALLY - Regenerate from config file instead.
# =============================================================================

'''


# =============================================================================
# UTILITIES
# =============================================================================

def sanitize_name(name: str) -> str:
    """Convert a name to a valid Terraform resource name (snake_case)."""
    # Replace spaces and special chars with underscores
    name = re.sub(r'[^a-zA-Z0-9]', '_', name.lower())
    # Remove consecutive underscores
    name = re.sub(r'_+', '_', name)
    # Remove leading/trailing underscores
    name = name.strip('_')
    # Ensure starts with letter
    if name and not name[0].isalpha():
        name = 'u_' + name
    return name


def generate_email(first_name: str, last_name: str, domain: str) -> str:
    """Generate an email address from name components."""
    first = sanitize_name(first_name).replace('_', '')
    last = sanitize_name(last_name).replace('_', '')
    return f"{first}.{last}@{domain}"


def load_config(config_path: Path) -> dict:
    """Load and parse the YAML configuration file."""
    if not config_path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    with open(config_path, 'r') as f:
        config = yaml.safe_load(f)

    return config


def validate_config(config: dict) -> list[str]:
    """Validate configuration against JSON schema."""
    errors = []

    if jsonschema is None:
        print("Warning: jsonschema not installed, skipping validation")
        return errors

    if not SCHEMA_FILE.exists():
        print(f"Warning: Schema file not found: {SCHEMA_FILE}")
        return errors

    with open(SCHEMA_FILE, 'r') as f:
        schema = json.load(f)

    try:
        jsonschema.validate(config, schema)
    except jsonschema.ValidationError as e:
        errors.append(f"Validation error: {e.message}")
        if e.path:
            errors.append(f"  Path: {'.'.join(str(p) for p in e.path)}")

    return errors


def resolve_output_dir(config: dict) -> Path:
    """Resolve the output directory from config, handling template variables."""
    output_config = config.get('output', {})
    directory = output_config.get('directory', 'environments/{{ environment.name }}/terraform')

    # Replace template variables
    env_name = config.get('environment', {}).get('name', 'myorg')
    directory = directory.replace('{{ environment.name }}', env_name)

    return REPO_ROOT / directory


# =============================================================================
# USER GENERATION
# =============================================================================

def generate_users(config: dict) -> list[dict]:
    """Generate user data from configuration."""
    users = []
    email_domain = config.get('environment', {}).get('email_domain', 'example.com')
    departments = config.get('departments', [])

    # Track managers for reference
    manager_map = {}

    # Process departments
    for dept in departments:
        dept_name = dept.get('name', 'Unknown')

        # Manager
        manager = dept.get('manager', {})
        if manager:
            first_name = manager.get('first_name', 'Manager')
            last_name = manager.get('last_name', dept_name)
            email = manager.get('email') or generate_email(first_name, last_name, email_domain)

            user_data = {
                'resource_name': sanitize_name(f"{first_name}_{last_name}"),
                'first_name': first_name,
                'last_name': last_name,
                'email': email,
                'login': email,
                'title': manager.get('title', f'{dept_name} Manager'),
                'department': dept_name,
                'is_manager': True,
                'status': 'ACTIVE',
            }
            users.append(user_data)
            manager_map[dept_name] = user_data

        # Employees
        employees = dept.get('employees', [])
        if isinstance(employees, list):
            # Explicit employee list
            for emp in employees:
                first_name = emp.get('first_name', 'Employee')
                last_name = emp.get('last_name', 'User')
                email = emp.get('email') or generate_email(first_name, last_name, email_domain)

                user_data = {
                    'resource_name': sanitize_name(f"{first_name}_{last_name}"),
                    'first_name': first_name,
                    'last_name': last_name,
                    'email': email,
                    'login': email,
                    'title': emp.get('title', 'Employee'),
                    'department': dept_name,
                    'is_manager': False,
                    'manager_dept': dept_name,
                    'status': 'ACTIVE',
                }
                users.append(user_data)

        elif isinstance(employees, dict) and 'count' in employees:
            # Auto-generate employees
            count = employees.get('count', 0)
            title_pattern = employees.get('title_pattern', 'Employee')

            for i in range(1, count + 1):
                first_name = f"{dept_name[:3]}{i:02d}"
                last_name = "Employee"
                email = generate_email(first_name, last_name, email_domain)

                user_data = {
                    'resource_name': sanitize_name(f"{first_name}_{last_name}"),
                    'first_name': first_name,
                    'last_name': last_name,
                    'email': email,
                    'login': email,
                    'title': f"{title_pattern} {i}",
                    'department': dept_name,
                    'is_manager': False,
                    'manager_dept': dept_name,
                    'status': 'ACTIVE',
                }
                users.append(user_data)

    # Additional users
    for user in config.get('additional_users', []):
        first_name = user.get('first_name', 'Additional')
        last_name = user.get('last_name', 'User')
        email = user.get('email') or generate_email(first_name, last_name, email_domain)

        user_data = {
            'resource_name': sanitize_name(f"{first_name}_{last_name}"),
            'first_name': first_name,
            'last_name': last_name,
            'email': email,
            'login': email,
            'title': user.get('title', ''),
            'department': user.get('department', ''),
            'user_type': user.get('user_type', 'employee'),
            'is_manager': False,
            'status': user.get('status', 'ACTIVE'),
        }
        users.append(user_data)

    return users


# =============================================================================
# GROUP GENERATION
# =============================================================================

def generate_groups(config: dict, users: list[dict]) -> list[dict]:
    """Generate group data from configuration."""
    groups = []
    departments = config.get('departments', [])

    # Department groups
    for dept in departments:
        dept_name = dept.get('name', 'Unknown')
        groups.append({
            'resource_name': sanitize_name(dept_name),
            'name': f"{dept_name} Team",
            'description': f"Members of the {dept_name} department",
            'members': [u['resource_name'] for u in users if u.get('department') == dept_name],
        })

    # Additional groups
    additional = config.get('groups', {}).get('additional', [])
    for group in additional:
        group_name = group.get('name', 'Unknown Group')
        description = group.get('description', '')
        members = []

        # Include departments
        include_depts = group.get('include_departments', [])
        for user in users:
            if user.get('department') in include_depts:
                members.append(user['resource_name'])

        # Include managers
        if group.get('include_managers', False):
            for user in users:
                if user.get('is_manager', False) and user['resource_name'] not in members:
                    members.append(user['resource_name'])

        # Include by title
        include_titles = group.get('include_titles', [])
        for user in users:
            if user.get('title', '') in include_titles and user['resource_name'] not in members:
                members.append(user['resource_name'])

        # Include by user type
        include_types = group.get('include_user_types', [])
        for user in users:
            if user.get('user_type', 'employee') in include_types and user['resource_name'] not in members:
                members.append(user['resource_name'])

        # Explicit members (by email)
        explicit_members = group.get('members', [])
        for email in explicit_members:
            for user in users:
                if user.get('email') == email and user['resource_name'] not in members:
                    members.append(user['resource_name'])

        groups.append({
            'resource_name': sanitize_name(group_name),
            'name': group_name,
            'description': description,
            'members': members,
        })

    return groups


# =============================================================================
# APPLICATION GENERATION
# =============================================================================

def generate_applications(config: dict) -> list[dict]:
    """Generate application data from configuration."""
    apps = []

    for app in config.get('applications', []):
        app_name = app.get('name', 'app')
        app_type = app.get('type', 'oauth_web')
        label = app.get('label', app_name.replace('_', ' ').title())
        description = app.get('description', '')
        assign_to = app.get('assign_to_groups', [])
        settings = app.get('settings', {})

        app_data = {
            'resource_name': sanitize_name(app_name),
            'label': label,
            'description': description,
            'assign_to_groups': assign_to,
        }

        # Set type-specific defaults
        if app_type == 'oauth_web':
            app_data.update({
                'type': 'web',
                'grant_types': settings.get('grant_types', ['authorization_code', 'refresh_token']),
                'redirect_uris': settings.get('redirect_uris', ['https://example.com/callback']),
                'response_types': ['code'],
                'pkce_required': True,
                'token_endpoint_auth_method': 'client_secret_post',
            })
        elif app_type == 'oauth_spa':
            app_data.update({
                'type': 'browser',
                'grant_types': ['authorization_code'],
                'redirect_uris': settings.get('redirect_uris', ['https://example.com/callback']),
                'response_types': ['code'],
                'pkce_required': True,
                'token_endpoint_auth_method': 'none',
            })
        elif app_type == 'oauth_service':
            app_data.update({
                'type': 'service',
                'grant_types': ['client_credentials'],
                'redirect_uris': [],
                'response_types': [],
                'token_endpoint_auth_method': 'client_secret_post',
            })
        elif app_type == 'oauth_native':
            app_data.update({
                'type': 'native',
                'grant_types': settings.get('grant_types', ['authorization_code', 'refresh_token']),
                'redirect_uris': settings.get('redirect_uris', ['com.example.app:/callback']),
                'response_types': ['code'],
                'pkce_required': True,
                'token_endpoint_auth_method': 'none',
            })
        elif app_type == 'saml':
            app_data.update({
                'type': 'saml',
                'sso_url': settings.get('sso_url', ''),
                'audience': settings.get('audience', ''),
                'recipient': settings.get('recipient', ''),
                'destination': settings.get('destination', ''),
            })

        apps.append(app_data)

    return apps


# =============================================================================
# TERRAFORM RENDERING
# =============================================================================

def render_users_tf(users: list[dict], config: dict, config_file: str) -> str:
    """Render users.tf content."""
    include_comments = config.get('output', {}).get('include_comments', True)

    content = TF_HEADER.format(
        title="USERS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    for user in users:
        if include_comments:
            content += f"# {user['first_name']} {user['last_name']} - {user.get('title', 'User')}\n"

        content += f'''resource "okta_user" "{user['resource_name']}" {{
  email      = "{user['email']}"
  first_name = "{user['first_name']}"
  last_name  = "{user['last_name']}"
  login      = "{user['login']}"
  status     = "{user['status']}"
'''
        if user.get('department'):
            content += f'  department = "{user["department"]}"\n'
        if user.get('title'):
            content += f'  title      = "{user["title"]}"\n'

        content += "}\n\n"

    return content


def render_groups_tf(groups: list[dict], config: dict, config_file: str) -> str:
    """Render groups.tf content."""
    include_comments = config.get('output', {}).get('include_comments', True)

    content = TF_HEADER.format(
        title="GROUPS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    for group in groups:
        if include_comments:
            content += f"# {group['name']}\n"

        content += f'''resource "okta_group" "{group['resource_name']}" {{
  name        = "{group['name']}"
  description = "{group['description']}"
}}

'''

    return content


def render_memberships_tf(groups: list[dict], config: dict, config_file: str) -> str:
    """Render group_memberships.tf content."""
    include_comments = config.get('output', {}).get('include_comments', True)

    content = TF_HEADER.format(
        title="GROUP MEMBERSHIPS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    for group in groups:
        if not group.get('members'):
            continue

        if include_comments:
            content += f"# Members of {group['name']}\n"

        members_list = ",\n    ".join([f"okta_user.{m}.id" for m in group['members']])
        depends_list = ",\n    ".join([f"okta_user.{m}" for m in group['members']])

        content += f'''resource "okta_group_memberships" "{group['resource_name']}" {{
  group_id = okta_group.{group['resource_name']}.id
  members = [
    {members_list},
  ]
  depends_on = [
    {depends_list},
  ]
}}

'''

    return content


def render_apps_tf(apps: list[dict], config: dict, config_file: str) -> str:
    """Render apps.tf content."""
    include_comments = config.get('output', {}).get('include_comments', True)

    content = TF_HEADER.format(
        title="APPLICATIONS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    for app in apps:
        if app.get('type') == 'saml':
            # SAML apps handled separately
            continue

        if include_comments:
            content += f"# {app['label']}\n"
            if app.get('description'):
                content += f"# {app['description']}\n"

        redirect_uris = '", "'.join(app.get('redirect_uris', []))
        grant_types = '", "'.join(app.get('grant_types', []))
        response_types = '", "'.join(app.get('response_types', []))

        content += f'''resource "okta_app_oauth" "{app['resource_name']}" {{
  label          = "{app['label']}"
  type           = "{app['type']}"
'''
        if grant_types:
            content += f'  grant_types    = ["{grant_types}"]\n'
        if redirect_uris:
            content += f'  redirect_uris  = ["{redirect_uris}"]\n'
        if response_types:
            content += f'  response_types = ["{response_types}"]\n'
        else:
            content += '  response_types = []\n'

        if app.get('pkce_required'):
            content += '  pkce_required              = true\n'
        if app.get('token_endpoint_auth_method'):
            content += f'  token_endpoint_auth_method = "{app["token_endpoint_auth_method"]}"\n'

        content += '''
  login_mode = "DISABLED"
  hide_ios   = true
  hide_web   = true

  user_name_template      = "$${source.login}"
  user_name_template_type = "BUILT_IN"
}

'''

    return content


def render_app_assignments_tf(apps: list[dict], groups: list[dict], config: dict, config_file: str) -> str:
    """Render app_assignments.tf content."""
    include_comments = config.get('output', {}).get('include_comments', True)

    # Build group name to resource name map
    group_map = {g['name']: g['resource_name'] for g in groups}
    # Also map department groups
    for dept in config.get('departments', []):
        dept_name = dept.get('name', '')
        group_map[dept_name] = sanitize_name(dept_name)

    content = TF_HEADER.format(
        title="APP GROUP ASSIGNMENTS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    for app in apps:
        for group_name in app.get('assign_to_groups', []):
            group_resource = group_map.get(group_name)
            if not group_resource:
                print(f"Warning: Group '{group_name}' not found for app '{app['label']}'")
                continue

            assignment_name = f"{app['resource_name']}_{group_resource}"

            if include_comments:
                content += f"# Assign {app['label']} to {group_name}\n"

            content += f'''resource "okta_app_group_assignment" "{assignment_name}" {{
  app_id   = okta_app_oauth.{app['resource_name']}.id
  group_id = okta_group.{group_resource}.id
}}

'''

    return content


def render_oig_tf(config: dict, config_file: str) -> str:
    """Render oig.tf content for entitlement bundles and access reviews."""
    oig_config = config.get('oig', {})
    if not oig_config.get('enabled', False):
        return ""

    include_comments = config.get('output', {}).get('include_comments', True)

    content = TF_HEADER.format(
        title="OIG - ENTITLEMENT BUNDLES AND ACCESS REVIEWS",
        config_file=config_file,
        timestamp=datetime.now().isoformat(),
    )

    if include_comments:
        content += '''# NOTE: Entitlement bundles define ACCESS PACKAGES.
# Bundle ASSIGNMENTS (who gets the bundle) are managed in Okta Admin UI.
# Terraform creates the bundle definition only.

'''

    # Entitlement bundles
    for bundle in oig_config.get('entitlement_bundles', []):
        bundle_name = bundle.get('name', 'Bundle')
        resource_name = sanitize_name(bundle_name)
        description = bundle.get('description', '')
        status = bundle.get('status', 'ACTIVE')

        if include_comments:
            content += f"# {bundle_name}\n"

        content += f'''resource "okta_entitlement_bundle" "{resource_name}" {{
  name        = "{bundle_name}"
  description = "{description}"
  status      = "{status}"
}}

'''

    # Access reviews
    for review in oig_config.get('access_reviews', []):
        review_name = review.get('name', 'Access Review')
        resource_name = sanitize_name(review_name)
        description = review.get('description', '')
        start_date = review.get('start_date', '')
        end_date = review.get('end_date', '')
        review_type = review.get('review_type', 'USER_ACCESS_REVIEW')
        reviewer_type = review.get('reviewer_type', 'MANAGER')

        if include_comments:
            content += f"# {review_name}\n"

        content += f'''resource "okta_reviews" "{resource_name}" {{
  name        = "{review_name}"
  description = "{description}"

  start_date = "{start_date}"
  end_date   = "{end_date}"

  review_type   = "{review_type}"
  reviewer_type = "{reviewer_type}"
}}

'''

    return content


# =============================================================================
# MAIN GENERATOR
# =============================================================================

def generate_terraform(config: dict, config_file: str) -> dict[str, str]:
    """Generate all Terraform files from configuration."""
    files = {}

    # Generate data
    users = generate_users(config)
    groups = generate_groups(config, users)
    apps = generate_applications(config)

    # Check if separate files or combined
    separate_files = config.get('output', {}).get('separate_files', True)
    prefix = config.get('output', {}).get('file_prefix', '')

    if separate_files:
        files[f'{prefix}users.tf'] = render_users_tf(users, config, config_file)
        files[f'{prefix}groups.tf'] = render_groups_tf(groups, config, config_file)
        files[f'{prefix}group_memberships.tf'] = render_memberships_tf(groups, config, config_file)
        files[f'{prefix}apps.tf'] = render_apps_tf(apps, config, config_file)
        files[f'{prefix}app_assignments.tf'] = render_app_assignments_tf(apps, groups, config, config_file)

        oig_content = render_oig_tf(config, config_file)
        if oig_content:
            files[f'{prefix}oig.tf'] = oig_content
    else:
        # Combined file
        combined = TF_HEADER.format(
            title="DEMO ENVIRONMENT",
            config_file=config_file,
            timestamp=datetime.now().isoformat(),
        )
        combined += render_users_tf(users, config, config_file)
        combined += render_groups_tf(groups, config, config_file)
        combined += render_memberships_tf(groups, config, config_file)
        combined += render_apps_tf(apps, config, config_file)
        combined += render_app_assignments_tf(apps, groups, config, config_file)
        combined += render_oig_tf(config, config_file)

        files[f'{prefix}demo.tf'] = combined

    return files


def write_files(files: dict[str, str], output_dir: Path, backup: bool = True) -> None:
    """Write generated files to disk."""
    output_dir.mkdir(parents=True, exist_ok=True)

    for filename, content in files.items():
        filepath = output_dir / filename

        # Backup existing file
        if backup and filepath.exists():
            backup_path = filepath.with_suffix(f'.tf.bak.{datetime.now().strftime("%Y%m%d%H%M%S")}')
            shutil.copy(filepath, backup_path)
            print(f"  Backed up: {filepath.name} -> {backup_path.name}")

        with open(filepath, 'w') as f:
            f.write(content)

        print(f"  Created: {filepath}")


def run_terraform_fmt(output_dir: Path) -> bool:
    """Run terraform fmt on generated files."""
    try:
        result = subprocess.run(
            ['terraform', 'fmt'],
            cwd=output_dir,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            print("  terraform fmt: OK")
            return True
        else:
            print(f"  terraform fmt: FAILED")
            print(f"  {result.stderr}")
            return False
    except FileNotFoundError:
        print("  terraform fmt: SKIPPED (terraform not found)")
        return True


def run_terraform_validate(output_dir: Path) -> bool:
    """Run terraform validate on generated files."""
    try:
        # First init if needed
        if not (output_dir / '.terraform').exists():
            init_result = subprocess.run(
                ['terraform', 'init', '-backend=false'],
                cwd=output_dir,
                capture_output=True,
                text=True,
            )
            if init_result.returncode != 0:
                print("  terraform init: FAILED")
                return False

        result = subprocess.run(
            ['terraform', 'validate'],
            cwd=output_dir,
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            print("  terraform validate: OK")
            return True
        else:
            print(f"  terraform validate: FAILED")
            print(f"  {result.stderr}")
            return False
    except FileNotFoundError:
        print("  terraform validate: SKIPPED (terraform not found)")
        return True


# =============================================================================
# CLI
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Generate Terraform files from Okta demo configuration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/build_demo.py --config demo-builder/demo-config.yaml
  python scripts/build_demo.py --config my-demo.yaml --dry-run
  python scripts/build_demo.py --config my-demo.yaml --validate
  python scripts/build_demo.py --config my-demo.yaml --output /tmp/test

For more information, see demo-builder/README.md
        """,
    )

    parser.add_argument(
        '--config', '-c',
        type=Path,
        required=True,
        help='Path to demo configuration YAML file',
    )

    parser.add_argument(
        '--output', '-o',
        type=Path,
        help='Override output directory from config',
    )

    parser.add_argument(
        '--dry-run', '-n',
        action='store_true',
        help='Show what would be generated without writing files',
    )

    parser.add_argument(
        '--validate', '-v',
        action='store_true',
        help='Run terraform fmt and validate after generation',
    )

    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Do not backup existing files before overwriting',
    )

    parser.add_argument(
        '--schema-check',
        action='store_true',
        help='Only validate config against schema, do not generate',
    )

    args = parser.parse_args()

    print(f"\n{'='*60}")
    print("Okta Demo Builder")
    print(f"{'='*60}\n")

    # Load configuration
    print(f"Loading configuration: {args.config}")
    try:
        config = load_config(args.config)
    except Exception as e:
        print(f"Error loading config: {e}")
        sys.exit(1)

    # Validate configuration
    print("Validating configuration...")
    errors = validate_config(config)
    if errors:
        print("Configuration errors:")
        for error in errors:
            print(f"  - {error}")
        sys.exit(1)
    print("  Configuration is valid")

    if args.schema_check:
        print("\nSchema check complete.")
        sys.exit(0)

    # Resolve output directory
    output_dir = args.output if args.output else resolve_output_dir(config)
    print(f"\nOutput directory: {output_dir}")

    # Generate files
    print("\nGenerating Terraform files...")
    files = generate_terraform(config, str(args.config))

    # Summary
    print(f"\nGenerated {len(files)} files:")
    for filename in files:
        lines = files[filename].count('\n')
        print(f"  - {filename} ({lines} lines)")

    if args.dry_run:
        print("\n[DRY RUN] No files written.")

        # Optionally show content
        for filename, content in files.items():
            print(f"\n{'='*60}")
            print(f"FILE: {filename}")
            print(f"{'='*60}")
            print(content[:2000])
            if len(content) > 2000:
                print(f"... ({len(content) - 2000} more characters)")

        sys.exit(0)

    # Write files
    print(f"\nWriting files to: {output_dir}")
    write_files(files, output_dir, backup=not args.no_backup)

    # Validate
    if args.validate:
        print("\nValidating generated files...")
        run_terraform_fmt(output_dir)
        run_terraform_validate(output_dir)

    print(f"\n{'='*60}")
    print("Generation complete!")
    print(f"{'='*60}")
    print(f"\nNext steps:")
    print(f"  1. Review generated files in: {output_dir}")
    print(f"  2. Run: cd {output_dir}")
    print(f"  3. Run: terraform init")
    print(f"  4. Run: terraform plan")
    print(f"  5. Run: terraform apply")
    print()


if __name__ == '__main__':
    main()
