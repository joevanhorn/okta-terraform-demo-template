# ==============================================================================
# AD INSTANCE MANAGEMENT WORKFLOW
# ==============================================================================
# Manage AD Domain Controller instances via AWS Systems Manager.
# Supports multiple operations: diagnose, reboot, reset admin password, etc.
#
# Usage:
#   gh workflow run ad-manage-instance.yml \
#     -f environment=taskvantage-prod \
#     -f domain=use1 \
#     -f action=diagnose
#
# For multi-domain environments (e.g., AMER and EMEA in same region):
#   -f domain=use1        # AMER domain
#   -f domain=use1-emea   # EMEA domain
# ==============================================================================

name: AD - Manage Instance

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: string
        default: 'myorg'
      domain:
        description: 'Domain identifier (e.g., use1, use1-emea)'
        required: true
        type: string
        default: 'use1'
      region:
        description: 'AWS region'
        required: true
        type: string
        default: 'us-east-1'
      action:
        description: 'Management action'
        required: true
        type: choice
        options:
          - diagnose
          - reboot
          - reset-password
          - check-services
          - get-users
          - get-groups
        default: 'diagnose'
      instance_id:
        description: 'EC2 Instance ID (leave empty to auto-detect)'
        required: false
        type: string
        default: ''

permissions:
  id-token: write
  contents: read

jobs:
  manage:
    name: "${{ inputs.action }} on AD Instance"
    runs-on: ubuntu-latest

    environment:
      name: ${{ inputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-AD-Manage
          aws-region: ${{ inputs.region }}

      - name: Get Instance ID
        id: get-instance
        run: |
          if [ -n "${{ inputs.instance_id }}" ]; then
            INSTANCE_ID="${{ inputs.instance_id }}"
          else
            INSTANCE_ID=$(aws ssm get-parameter \
              --name "/${{ inputs.environment }}/${{ inputs.domain }}/ad/instance-id" \
              --query "Parameter.Value" \
              --output text \
              --region ${{ inputs.region }} 2>/dev/null || echo "")

            if [ -z "$INSTANCE_ID" ]; then
              echo "Error: Could not find instance ID"
              exit 1
            fi
          fi

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Instance ID: $INSTANCE_ID"

      - name: Verify Instance State
        run: |
          INSTANCE_STATE=$(aws ec2 describe-instances \
            --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
            --query "Reservations[0].Instances[0].State.Name" \
            --output text \
            --region ${{ inputs.region }})

          echo "Instance state: $INSTANCE_STATE"

          if [ "$INSTANCE_STATE" != "running" ] && [ "${{ inputs.action }}" != "reboot" ]; then
            echo "Warning: Instance is not running"
          fi

      # =========================================================================
      # DIAGNOSE ACTION
      # =========================================================================
      - name: Run Diagnostics
        if: inputs.action == 'diagnose'
        id: diagnose
        run: |
          # Write PowerShell script to temp file for proper JSON escaping
          cat > /tmp/diagnose.ps1 <<'PWSH'
          Write-Output "=========================================="
          Write-Output "AD DOMAIN CONTROLLER DIAGNOSTICS"
          Write-Output "$(Get-Date)"
          Write-Output "=========================================="

          Write-Output ""
          Write-Output "=== System Information ==="
          Get-ComputerInfo | Select-Object CsName, WindowsVersion, OsArchitecture, CsTotalPhysicalMemory | Format-List

          Write-Output ""
          Write-Output "=== AD Domain Status ==="
          try {
              $Domain = Get-ADDomain
              Write-Output "Domain: $($Domain.DNSRoot)"
              Write-Output "Forest: $($Domain.Forest)"
              Write-Output "Domain Mode: $($Domain.DomainMode)"
              Write-Output "PDC Emulator: $($Domain.PDCEmulator)"
          } catch {
              Write-Output "AD Domain not configured or not accessible"
          }

          Write-Output ""
          Write-Output "=== Critical Services ==="
          $Services = @("NTDS", "DNS", "Netlogon", "W32Time", "DFSR", "AmazonSSMAgent", "OktaAgentSvc")
          foreach ($Svc in $Services) {
              $Status = Get-Service -Name $Svc -ErrorAction SilentlyContinue
              if ($Status) {
                  Write-Output "$Svc : $($Status.Status)"
              } else {
                  Write-Output "$Svc : Not Found"
              }
          }

          Write-Output ""
          Write-Output "=== Disk Space ==="
          Get-PSDrive -PSProvider FileSystem | Select-Object Name, @{N="Used(GB)";E={[math]::Round($_.Used/1GB,2)}}, @{N="Free(GB)";E={[math]::Round($_.Free/1GB,2)}} | Format-Table

          Write-Output ""
          Write-Output "=== Recent Event Log Errors (last 24h) ==="
          Get-EventLog -LogName System -EntryType Error -After (Get-Date).AddHours(-24) -ErrorAction SilentlyContinue | Select-Object -First 10 TimeGenerated, Source, Message | Format-Table -Wrap

          Write-Output ""
          Write-Output "=== Network Configuration ==="
          Get-NetIPConfiguration | Select-Object InterfaceAlias, IPv4Address, IPv4DefaultGateway | Format-Table

          Write-Output ""
          Write-Output "=== DNS Server Configuration ==="
          try {
              Get-DnsServerZone | Select-Object ZoneName, ZoneType, IsDsIntegrated | Format-Table
          } catch {
              Write-Output "DNS Server not configured"
          }

          Write-Output ""
          Write-Output "Diagnostics complete"
          PWSH

          # Create properly escaped JSON parameters using jq
          PARAMS=$(jq -n --rawfile script /tmp/diagnose.ps1 '{"commands": [$script]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS" \
            --timeout-seconds 300 \
            --region ${{ inputs.region }} \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      # =========================================================================
      # REBOOT ACTION
      # =========================================================================
      - name: Reboot Instance
        if: inputs.action == 'reboot'
        run: |
          echo "Rebooting instance ${{ steps.get-instance.outputs.instance_id }}..."
          aws ec2 reboot-instances \
            --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
            --region ${{ inputs.region }}

          echo "Reboot initiated. Instance will be back online in a few minutes."
          echo "## Instance Reboot" >> $GITHUB_STEP_SUMMARY
          echo "Reboot initiated for instance \`${{ steps.get-instance.outputs.instance_id }}\`" >> $GITHUB_STEP_SUMMARY

      # =========================================================================
      # RESET PASSWORD ACTION
      # =========================================================================
      - name: Reset Administrator Password
        if: inputs.action == 'reset-password'
        id: reset-password
        run: |
          # Get secret ARN
          SECRET_ARN=$(aws ssm get-parameter \
            --name "/${{ inputs.environment }}/${{ inputs.domain }}/ad/credentials-secret-arn" \
            --query "Parameter.Value" \
            --output text \
            --region ${{ inputs.region }} 2>/dev/null || echo "")

          if [ -z "$SECRET_ARN" ]; then
            # Try to find it by name pattern
            SECRET_ARN=$(aws secretsmanager list-secrets \
              --filters "Key=name,Values=${{ inputs.environment }}" \
              --query "SecretList[?contains(Name, 'ad-credentials')].ARN | [0]" \
              --output text \
              --region ${{ inputs.region }})
          fi

          if [ -z "$SECRET_ARN" ] || [ "$SECRET_ARN" = "None" ]; then
            echo "Error: Could not find AD credentials secret"
            exit 1
          fi

          # Generate new password
          NEW_PASSWORD=$(openssl rand -base64 16 | tr -dc 'A-Za-z0-9!@#$%' | head -c 20)

          # Update Secrets Manager
          aws secretsmanager update-secret \
            --secret-id "$SECRET_ARN" \
            --secret-string "{\"admin_password\":\"$NEW_PASSWORD\",\"safe_mode_password\":\"$NEW_PASSWORD\"}" \
            --region ${{ inputs.region }}

          echo "Secrets Manager updated with new password"

          # Reset password on instance
          SCRIPT="Set-LocalUser -Name Administrator -Password (ConvertTo-SecureString '$NEW_PASSWORD' -AsPlainText -Force); Write-Output 'Password reset successful'"

          # Create properly escaped JSON parameters using jq
          PARAMS=$(echo "$SCRIPT" | jq -Rs '{"commands": [.]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS" \
            --timeout-seconds 60 \
            --region ${{ inputs.region }} \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          echo "Password reset command sent"

          echo "## Password Reset" >> $GITHUB_STEP_SUMMARY
          echo "Administrator password has been reset." >> $GITHUB_STEP_SUMMARY
          echo "Retrieve new credentials from Secrets Manager: \`$SECRET_ARN\`" >> $GITHUB_STEP_SUMMARY

      # =========================================================================
      # CHECK SERVICES ACTION
      # =========================================================================
      - name: Check Services
        if: inputs.action == 'check-services'
        id: check-services
        run: |
          SCRIPT='Get-Service | Where-Object {$_.Status -eq "Running" -or $_.Name -match "Okta|NTDS|DNS|SSM"} | Sort-Object Status, Name | Format-Table Name, Status, DisplayName -AutoSize'

          # Create properly escaped JSON parameters using jq
          PARAMS=$(echo "$SCRIPT" | jq -Rs '{"commands": [.]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS" \
            --timeout-seconds 60 \
            --region ${{ inputs.region }} \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      # =========================================================================
      # GET USERS ACTION
      # =========================================================================
      - name: Get AD Users
        if: inputs.action == 'get-users'
        id: get-users
        run: |
          SCRIPT='Get-ADUser -Filter * -Properties Department, Title, Enabled | Select-Object SamAccountName, Name, Department, Title, Enabled | Format-Table -AutoSize'

          # Create properly escaped JSON parameters using jq
          PARAMS=$(echo "$SCRIPT" | jq -Rs '{"commands": [.]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS" \
            --timeout-seconds 120 \
            --region ${{ inputs.region }} \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      # =========================================================================
      # GET GROUPS ACTION
      # =========================================================================
      - name: Get AD Groups
        if: inputs.action == 'get-groups'
        id: get-groups
        run: |
          SCRIPT='Get-ADGroup -Filter * | Select-Object Name, GroupCategory, GroupScope | Sort-Object Name | Format-Table -AutoSize'

          # Create properly escaped JSON parameters using jq
          PARAMS=$(echo "$SCRIPT" | jq -Rs '{"commands": [.]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunPowerShellScript" \
            --parameters "$PARAMS" \
            --timeout-seconds 120 \
            --region ${{ inputs.region }} \
            --query "Command.CommandId" \
            --output text)

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      # =========================================================================
      # WAIT FOR COMMAND COMPLETION
      # =========================================================================
      - name: Wait for Command Completion
        if: inputs.action != 'reboot'
        id: wait-command
        run: |
          COMMAND_ID=""
          case "${{ inputs.action }}" in
            diagnose) COMMAND_ID="${{ steps.diagnose.outputs.command_id }}" ;;
            reset-password) COMMAND_ID="${{ steps.reset-password.outputs.command_id }}" ;;
            check-services) COMMAND_ID="${{ steps.check-services.outputs.command_id }}" ;;
            get-users) COMMAND_ID="${{ steps.get-users.outputs.command_id }}" ;;
            get-groups) COMMAND_ID="${{ steps.get-groups.outputs.command_id }}" ;;
          esac

          if [ -z "$COMMAND_ID" ]; then
            echo "No command ID found"
            exit 0
          fi

          echo "Waiting for command $COMMAND_ID..."

          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
              --query "Status" \
              --output text \
              --region ${{ inputs.region }} 2>/dev/null || echo "Pending")

            if [ "$STATUS" = "Success" ]; then
              echo "Command completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "Command failed with status: $STATUS"
              break
            fi

            echo "Status: $STATUS ($i/60)"
            sleep 5
          done

          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      - name: Display Results
        if: inputs.action != 'reboot'
        run: |
          COMMAND_ID=""
          case "${{ inputs.action }}" in
            diagnose) COMMAND_ID="${{ steps.diagnose.outputs.command_id }}" ;;
            reset-password) COMMAND_ID="${{ steps.reset-password.outputs.command_id }}" ;;
            check-services) COMMAND_ID="${{ steps.check-services.outputs.command_id }}" ;;
            get-users) COMMAND_ID="${{ steps.get-users.outputs.command_id }}" ;;
            get-groups) COMMAND_ID="${{ steps.get-groups.outputs.command_id }}" ;;
          esac

          if [ -z "$COMMAND_ID" ]; then
            exit 0
          fi

          # Get and display results (both in log and summary)
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}" \
            --query "StandardOutputContent" \
            --output text \
            --region ${{ inputs.region }})

          # Output to log
          echo "=========================================="
          echo "${{ inputs.action }} Results"
          echo "=========================================="
          echo "$OUTPUT"

          # Output to job summary
          echo "## ${{ inputs.action }} Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "$OUTPUT" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
